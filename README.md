"# LeetCode" 
# 仓库说明
## 1.时间轴
|<center>时间</center>|<center>记录内容</center>|<center>备注</center>|
|:---|:---|:---|
|2019年9月29日10:12:19|开始着手刷题|起步|

## 2.内容描述
&emsp;&emsp;本仓库链接：https://github.com/guyongpu/LeetCode.git  
&emsp;&emsp;本仓库为LeetCode刷题记录，网址为：https://leetcode-cn.com/problemset/all/ ，[点击跳转到LeetCode中文题库](https://leetcode-cn.com/problemset/all/)
每个题的代码放在src中，在main.cpp设置number的值，numbers为题目编号，然后运行测试函数即可，例如需要运行题1时，在main.cpp中设置number=1即可:
~~~ c++
#include <iostream>

#include "src/P0000_ProblemHead.h"

using namespace std;

int main() {
    int number = 1;
    Test_Problem(number);
    cout << "Probelem " << number << " test finish!" << endl;
    return 0;
}
~~~

&emsp;&emsp;然后点击运行即可，题1结果如下：
~~~c++
2 4
Probelem 1 test finish!

Process finished with exit code 0
~~~

## 3.文件说明
|<center>文件名</center>|<center>内容描述</center>|
|:---|:---|
|P0000_CommonHead.h|用于声明一些公用的结构体或者函数，如树节点、链表节点等，在需要的时候引用.|
|P0000_ProblemHead.h|用于测试的头文件，则其中引入各个文件的头文件，用于创建各个问题的类.|
|P0000_ProblemHead.cpp|用于测试的源程序，在switch函数中创建并调用各个问题类的test()函数进行运行测试.|
|Pxxxx_*******.h|表示编号为xxxx问题的类的头文件.|
|Pxxxx_*******.cpp|表示编号为xxxx问题的类的头文件相对应的源程序.|

## 4.刷题日志
|<center>题号</center>|<center>题目名</center>|<center>完成日期</center>|<center>描述</center>|<center>备注</center>|
|:---:|:---:|:---:|:---|:---|
|P0001|两数之和|2019.9.29|描述：给定一个整数数组nums和target，求该数组中两个和为target的整数，返回下标.<br>思路：排序，然后使用双指针做法，最后计算下标.<br>复杂度：空间O(n),时间O(3n)|排序+首尾双指针|
|P0002|两数相加|2019.9.29|描述：两个非空的链表用来表示两个非负的整数，将这两个数相加起来，则会返回一个新的链表来表示它们的和.<br>思路：采用链表合并思想，1.当都不为空时，逐个合并；2.其中一个为空，则单独对另一个处理；3.最后处理carry可能存在的进位.<br>复杂度：空间O(max(N,M)),时间O(max(N,M))|链表合并思想+处理最后的carry|
|P0003|无重复字符的最长子串|2019.10.8|描述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度.<br>思路：使用滑动窗口来做，记录队列最长的值|还可以使用map进行优化|
|P0004|寻找两个有序数组的中位数|2019.10.10|描述：给定两个大小为m和n的有序数组nums1和nums2，找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n)).<br>思路：使用有序数组合并的思路，记录遍历的个数，当满足 cnt = mid 时，则说明已经遍历一半.|数组合并思路|
|P0146|LRU缓存机制|2019.9.29|描述：运用你所掌握的数据结构，设计和实现一个LRU(最近最少使用)缓存机制。它应该支持以下操作：获取数据get和写入数据put.<br>思路：使用哈希表和双向链表实现.|多复习|
|P0147|对链表进行插入排序|2019.9.30|描述：按照插入排序的思想，对链表进行插入排序.<br>思路：在进行插入排序的时候，对当前待处理节点要保留 NodeFront、NodeCurrent、NodeNext三个节点，对于比较节点要保留 pNode0 和 pNode。|面试题，要复习|
|P0148|排序链表|2019.10.8|描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序.<br>思路：对链表进行快速排序或归并排序进行实现均可，和普通的数组排序有所不同，要注意区分.|该题比较重要，要注意复习|
|P0149|直线上最多的点|2019.10.8|描述：给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上.<br>思路：对每个点进行计算通过第i个点的点的数量，对于每一个点，将斜率的分子分母约分后存储到map中.|重合的点不用计算，直接+1就行.|
|P0150|逆波兰表达式求值|2019.10.8|描述：根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式.<br>思路：构造一个stack<int>numbers用于存放计算结果，每次遇到运算符则弹出两个元素计算，并把结果存入到numbers中.|题目不难，记得思路即可.|
|P0151|翻转字符串里的单词|2019.10.8|描述：给定一个字符串，逐个翻转字符串中的每个单词.<br>思路：运用公式 BA = （A^T B^T)^T，先对每个单词翻转，然后再整个字符串翻转。最后去除多余空格，去除首尾空格，及处理特殊字符串.|题目本身不难，但是在处理空格时要仔细.|
|P0152|乘积最大子序列|2019.10.9|描述：给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）.<br>思路：令imax为当前最大值，imax = max(imax * nums[i], nums[i])，负数会导致大变小，小变大，故需要维护当前最小值，当负数出现时imax与imin交换再进行下一步计算.|需要复习|
|P0153|寻找旋转排序数组中的最小值|2019.10.10|描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转，请找出其中最小的元素.<br>思路：此题是剑指Offer上原题，采用二分查找的思想做，每次用 num[start]与num[mid]比较，最终start指向最大元素，last指向最小元素.|注意循环条件|
|P0154|寻找旋转排序数组中的最小值II|2019.10.10|描述：假设按照升序排序的数组在预先未知的某个点上进行了旋转，请找出其中最小的元素，注意数组中可能存在重复的元素.<br>思路：在二分查找的思路下，考虑重复元素的情况，如果遇到相等情况，无法判断mid处的位置，只能在[start , last]之间遍历查找.|考虑重复元素|
|P0155|最小栈|2019.10.10|描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈.<br>思路：法1：使用辅助栈，相等时要一起push和pop；法2：只用一个栈，栈顶第一个为最小数据。第二个为实际的数据.|两种方法均须掌握|